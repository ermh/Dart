/*
 * Copyright (c) 2011, the Dart project authors.
 * 
 * Licensed under the Eclipse Public License v1.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.dart.tools.core.generator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Status;

import java.util.HashMap;

/**
 * Instances of <code>DartHtmlGenerator</code> are used to create a simple HTML file containing a
 * reference to a JavaScript file.
 */
public class DartHtmlGenerator extends DartFileGenerator {
  public static final String HTML_FILENAME_EXTENSION = ".html";

  /**
   * The title in the generated HTML page
   */
  private String title = "";

  /**
   * The Dart application file referenced in the generated HTML page
   */
  private IFile dartAppFile = null;

  /**
   * Construct a new instance.
   * 
   * @param containerMustExist If <code>true</code> then the container must exist for the
   *          {@link #validateContainer()} method to return <code>true</code>.
   */
  public DartHtmlGenerator(boolean containerMustExist) {
    super(containerMustExist);
  }

  /**
   * Generate the new type
   * 
   * @param monitor the progress monitor (not <code>null</code>)
   */
  public void execute(IProgressMonitor monitor) throws CoreException {
    final HashMap<String, String> substitutions = new HashMap<String, String>();
    substitutions.put("title", getTitle());
    substitutions.put("dartPath", getRelativeDartPath());
    execute("generated-html.txt", getFile(), substitutions, monitor);
  }

  /**
   * Answer the Dart application file referenced in the generated HTML page
   */
  public IFile getDartAppFile() {
    return dartAppFile;
  }

  /**
   * Answer the file to be created
   * 
   * @return the file or <code>null</code> if a file cannot be created
   */
  public IFile getFile() {
    if (!validate().isOK()) {
      return null;
    }
    String fileName = getName();
    if (!fileName.endsWith(HTML_FILENAME_EXTENSION)) {
      fileName += HTML_FILENAME_EXTENSION;
    }
    return getContainer().getFile(new Path(fileName));
  }

  /**
   * Answer the title in the generated HTML page
   */
  public String getTitle() {
    return title;
  }

  /**
   * Set the Dart application file referenced in the generated HTML page
   */
  public void setDartAppFile(IFile file) {
    this.dartAppFile = file;
  }

  /**
   * Set the title in the generated HTML page
   */
  public void setTitle(String title) {
    this.title = title != null ? title : "";
  }

  @Override
  public IStatus validate() {
    IStatus status = validateContainer();
    if (!status.isOK()) {
      return status;
    }
    status = ResourcesPlugin.getWorkspace().validateName(getName(), IResource.FILE);
    if (!status.isOK()) {
      return status;
    }
    if (getTitle().length() == 0) {
      return error("Title is unspecified");
    }
    if (getDartAppFile() == null) {
      return error("Dart application file is unspecified");
    }
    return Status.OK_STATUS;
  }

  /**
   * Answer a relative path from the file generated by the receiver to the Dart application file
   * (e.g. "../js/Clock.app.js")
   * 
   * @return the relative path (not <code>null</code>)
   */
  private String getRelativeDartPath() {
    IPath srcPath = getFile().getParent().getFullPath();
    IPath dstPath = getDartAppFile().getFullPath();
    int start = srcPath.matchingFirstSegments(dstPath);
    String result = dstPath.removeFirstSegments(start).toString();
    for (int i = start; i < srcPath.segmentCount(); i++) {
      result = "../" + result;
    }
    return result;
  }
}
